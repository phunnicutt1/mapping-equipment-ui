export interface BACnetPoint {
  id: string;
  dis: string;
  navName?: string;
  unit?: string | null; // Allow null for backward compatibility
  kind?: string;
  equipRef?: string | null;
  bacnetCur?: string;
  bacnetDesc?: string;
  bacnetDis?: string;
  bacnetConnRef?: string;
  bacnetDeviceName?: string;
  vendor?: string;
  model?: string;
  siteRef?: string;
  status?: 'unassigned' | 'suggested' | 'confirmed' | 'flagged';
  confidence?: number;
  point?: string;
  writable?: string;
  cmd?: string;
  sensor?: string;
  his?: string;
  curVal?: any;
  curStatus?: string;
  curErr?: string;
  writeStatus?: string;
  writeErr?: string;
  fileName?: string;
  // Additional properties for backward compatibility
  markers?: string[];
  source?: string;
  equipName?: string;
}

export interface EquipmentType {
  id: string;
  name: string;
  description?: string;
  category?: string;
  color?: string; // Random color assigned when equipment type is created
  templates?: EquipmentTemplate[]; // Available templates for this type
  // DEPRECATED: Legacy pattern-based properties (kept for backward compatibility)
  pattern?: RegExp;
  confidence?: number;
  pointPatterns?: string[];
  minPoints?: number;
  maxPoints?: number;
}

export interface EquipmentInstance {
  id: string;
  name: string;
  typeId: string;
  confidence: number;
  status: 'suggested' | 'confirmed' | 'needs-review' | 'flagged';
  pointIds: string[];
  vendor?: string;
  model?: string;
  bacnetDeviceName?: string;
  templateId?: string; // Reference to applied template
  // ML pipeline properties
  cluster?: number; // Cluster assignment from K-Modes clustering
  fileName?: string; // Source file name for backward compatibility
}

export interface EquipmentTemplate {
  id: string;
  name: string;
  equipmentTypeId: string;
  createdFrom: string; // Equipment instance ID this was created from
  pointSignature: PointSignature[];
  featureVector: number[];
  createdAt: Date;
  appliedCount: number; // How many times this template has been applied
  color: string; // Random color assigned when template is created (e.g., 'bg-blue-500')
  confidence?: number; // ML-generated confidence score for the template
  // Advanced ML template management features
  version: number; // Template version for tracking refinements
  parentTemplateId?: string; // Reference to parent template if this is a refined version
  isMLGenerated: boolean; // Whether this template was generated by ML or manually created
  effectiveness: TemplateEffectiveness; // Tracking template performance
  userFeedback: TemplateUserFeedback[]; // User feedback for template improvement
  tags: string[]; // Searchable tags for template organization
  description?: string; // Optional description for template purpose
  lastModified: Date; // Last modification timestamp
  isActive: boolean; // Whether template is active for auto-application
  similarityThreshold: number; // Threshold for auto-application (0.0-1.0)
  autoApplyEnabled: boolean; // Whether to automatically apply this template
}

export interface PointSignature {
  navName: string;
  kind?: string;
  unit?: string | null; // Allow null for backward compatibility
  bacnetPointType?: string; // e.g., 'AO', 'AI', 'BO', 'BI'
  properties: string[]; // e.g., ['point', 'writable', 'cmd']
  isRequired: boolean;
}

export interface ProcessingStats {
  totalPoints: number;
  assignedPoints: number;
  equipmentGroups: number;
  templatedEquipment?: number; // New stat for template usage
  confidenceDistribution: {
    high: number;
    medium: number;
    low: number;
  };
}

export interface ConsoleMessage {
  id: string;
  timestamp: Date;
  level: 'info' | 'warning' | 'error' | 'success';
  message: string;
}

export type GroupingMethod = 'none' | 'kind' | 'unit' | 'smart';

export interface GroupingState {
  points: BACnetPoint[];
  equipmentTypes: EquipmentType[];
  equipmentInstances: EquipmentInstance[];
  templates: EquipmentTemplate[]; // Global template storage
  suggestedTemplates: EquipmentTemplate[];
  stats: ProcessingStats;
  consoleMessages: ConsoleMessage[];
  selectedGroupingMethod: GroupingMethod;
  isProcessing: boolean;
  showUnassignedDrawer: boolean;
  showConfirmedDrawer: boolean;
  selectedPoints: Set<string>;
  showCelebration: boolean;
  isComplete: boolean;
  templateToInspect: EquipmentTemplate | null;
  // UI state for equipment expansion/collapse (human review process)
  expandedEquipmentTypes: Set<string>; // Which equipment type containers are expanded
  expandedEquipment: Set<string>; // Which individual equipment are expanded to show points
  // Advanced template management state
  templateSimilarityMatches: TemplateSimilarityMatch[]; // Pending similarity matches
  templateAnalytics: TemplateAnalytics; // Template performance analytics
  showTemplateManager: boolean; // Whether template management UI is open
  // Anomaly detection state
  anomalies: AnomalyInstance[]; // Detected anomalous equipment
  newEquipmentTypeCandidates: NewEquipmentTypeCandidate[]; // Candidates for new equipment types
  showAnomalyPanel: boolean; // Whether anomaly review panel is open
  anomalyDetectionResults?: AnomalyDetectionResult; // Last detection results
  // Performance monitoring state
  showPerformanceDashboard: boolean; // Whether performance dashboard is open
  // Analytics data
  analytics?: any; // Processing analytics data
}

export interface ProcessingResult {
  equipmentInstances: EquipmentInstance[];
  equipmentTemplates: EquipmentTemplate[];
  allPoints: BACnetPoint[];
  anomalyDetectionResult?: AnomalyDetectionResult; // Optional anomaly detection results
  equipmentTypes?: EquipmentType[]; // Equipment types from processing
  templates?: EquipmentTemplate[]; // Alternative name for equipmentTemplates for backward compatibility
  analytics?: any; // Analytics data from processing
}

export interface GroupingActions {
  loadPoints: (points: BACnetPoint[]) => void; // DEPRECATED: Use loadProcessedData instead
  loadProcessedData: (result: ProcessingResult) => void;
  setGroupingMethod: (method: GroupingMethod) => void;
  addConsoleMessage: (message: Omit<ConsoleMessage, 'id' | 'timestamp'>) => void;
  toggleUnassignedDrawer: (open?: boolean) => void;
  toggleConfirmedDrawer: (open?: boolean) => void;
  togglePointSelection: (pointId: string) => void;
  clearSelection: () => void;
  assignPointsToEquipment: (equipmentId: string, pointIds: string[]) => void;
  confirmEquipment: (equipmentId: string) => void;
  flagEquipment: (equipmentId: string) => void;
  createTemplateFromEquipment: (equipmentId: string) => void;
  applyTemplateToEquipment: (templateId: string, equipmentId: string) => void;
  saveDraft: () => Promise<void>;
  checkCompletion: () => void;
  resetCelebration: () => void;
  // Anomaly detection actions
  toggleAnomalyPanel: () => void;
  reviewAnomaly: (anomalyId: string, action: 'confirm' | 'classify' | 'dismiss') => void;
  assignAnomalyToEquipmentType: (anomalyId: string, equipmentTypeId: string) => void;
  createEquipmentTypeFromAnomalies: (anomalyIds: string[], typeName: string, description: string) => Promise<{ success: boolean; typeId?: string }>;
  groupSimilarAnomalies: (anomalyIds: string[]) => Promise<{ success: boolean; candidateId?: string }>;
  runAnomalyDetection: (threshold?: number) => Promise<AnomalyDetectionResult>;
  approveNewEquipmentType: (candidateId: string) => Promise<{ success: boolean; typeId?: string }>;
  rejectNewEquipmentType: (candidateId: string, reason: string) => void;
  // Performance monitoring actions
  togglePerformanceDashboard: () => void;
}

// Advanced template management interfaces
export interface TemplateEffectiveness {
  successfulApplications: number; // Number of successful auto-applications
  failedApplications: number; // Number of failed auto-applications
  userConfirmations: number; // Number of times user confirmed auto-applied template
  userRejections: number; // Number of times user rejected auto-applied template
  averageConfidenceScore: number; // Average confidence of successful applications
  lastApplicationDate?: Date; // Last time template was applied
  successRate: number; // Calculated success rate (0.0-1.0)
}

export interface TemplateUserFeedback {
  id: string;
  userId?: string; // Optional user identifier
  feedbackType: 'positive' | 'negative' | 'suggestion';
  message: string;
  timestamp: Date;
  equipmentInstanceId?: string; // Reference to equipment where feedback was given
  suggestedChanges?: Partial<EquipmentTemplate>; // Suggested template modifications
}

export interface TemplateSimilarityMatch {
  templateId: string;
  equipmentInstanceId: string;
  similarityScore: number; // 0.0-1.0
  matchingPoints: string[]; // Point IDs that match
  confidence: number; // Confidence in the match
  autoApplied: boolean; // Whether it was automatically applied
  userConfirmed?: boolean; // Whether user confirmed the match
}

export interface TemplateAnalytics {
  totalTemplates: number;
  activeTemplates: number;
  mlGeneratedTemplates: number;
  userCreatedTemplates: number;
  totalApplications: number;
  successfulApplications: number;
  averageSuccessRate: number;
  mostUsedTemplateId?: string;
  leastUsedTemplateId?: string;
  recentActivity: TemplateActivity[];
}

export interface TemplateActivity {
  id: string;
  templateId: string;
  templateName: string;
  action: 'created' | 'applied' | 'refined' | 'deactivated' | 'feedback';
  timestamp: Date;
  equipmentInstanceId?: string;
  details?: string;
}

// Anomaly Detection Interfaces
export interface AnomalyInstance {
  id: string;
  name: string;
  pointIds: string[];
  dissimilarityScore: number; // How different this is from existing clusters
  confidence: number; // Confidence that this is truly anomalous
  status: 'detected' | 'reviewing' | 'confirmed-anomaly' | 'classified' | 'dismissed';
  detectionMethod: 'dissimilarity-threshold' | 'outlier-analysis' | 'cluster-distance';
  detectedAt: Date;
  suggestedActions: AnomalySuggestedAction[];
  reviewedBy?: string; // User who reviewed this anomaly
  reviewedAt?: Date;
  newEquipmentTypeCandidate?: boolean; // Whether this might represent a new equipment type
  similarAnomalies: string[]; // IDs of other similar anomalies for grouping
  fileName?: string; // Source file for traceability
}

export interface AnomalySuggestedAction {
  type: 'create-new-type' | 'assign-to-existing' | 'mark-outlier' | 'group-with-similar';
  description: string;
  confidence: number;
  targetEquipmentTypeId?: string; // For assign-to-existing action
  similarAnomalyIds?: string[]; // For group-with-similar action
}

export interface AnomalyDetectionResult {
  anomalies: AnomalyInstance[];
  totalProcessed: number;
  anomalyRate: number; // Percentage of equipment that are anomalies
  detectionThreshold: number; // Threshold used for detection
  clusterQualityMetrics: {
    averageSilhouetteScore: number;
    clusterSeparation: number;
    intraClusterDistance: number;
  };
}

export interface NewEquipmentTypeCandidate {
  id: string;
  name: string;
  description: string;
  anomalyIds: string[]; // Source anomalies grouped into this candidate
  confidence: number;
  commonFeatures: number[]; // Feature vector representing common characteristics
  pointSignature: PointSignature[];
  createdAt: Date;
  status: 'candidate' | 'approved' | 'rejected';
  userFeedback?: string;
}